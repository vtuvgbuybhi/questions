#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

//问题描述    --》在一堆数中只有一个数的以单数出现   剩下的数都是成对出现，那么怎么找出这个以单数出现的数呢--一个单身狗问题

//两个单身狗问题 ---》 就是有两个数是以单数出现
//三个单身狗问题 ---》

//在解决以上问题时--->我们得先了解    异或操作符

//异或操作符是一种位运算   --》位指的是二进制位（二进制位相同位0，相异位1）
//int main()
//{
//	int a = 6;
//	int b = 7;
//	printf("%d\n", a ^ b);
//
//	//a   :       110
//	//b   :       111
// //   a^b :       001
//	return 0;
//}

//int main()
//{
//	int a = 5;
//	int b = 0;
//	printf("%d\n", a ^ b);
//
//	a:    110
//	b:    000
//  a^b:    110
//
//	任何数与0异或都是得到的结果都是他本身
//
//	return 0;
//}

//int main()
//{
//	int a = 5;
//	int b = 5;
//
//	a:  110
//	b:  110
//   a^b: 000
//	任何数与他本身异或得到的都是0
//	return 0;
//}

//同时异或操作符还满足   --> 交换律和结合律

//异或还可以求解一个问题  -->如何交换两个元素再不引用第三个变量的情况下

//int main()
//{
//	int a = 5;
//	int b = 8;
//
//	a = a ^ b;
//
//	b = a ^ b;
//	//b=a^b^b    =  a^0=b
//
//	a = a ^ b;
//	//a=a^b  ^a^b^b  =b^0^0
//
//	printf("a=%d  b=%d ", a, b);
//	return 0;
//}

//好了现在我们学会了异或操作符我们现在开始讲一个单身狗的问题

//首先我们先用最简单的方法--》暴力求解法

//我们先将数组排序  -->  排序完后两两元素相减  --》 不等于0  那么就是相减的第一个元素是单身狗

void Shell_sort(int arr[], int sz)
{
	int gap = sz;
	while (gap > 1)
	{
		gap = gap / 3 + 1;
		int i = 0;
		for (i = 0; i < sz - gap; i++)
		{
			int end = i;
			int temp = arr[end + gap];
			while (end >= 0)
			{
				if (arr[end] > arr[end + gap])
				{
					arr[end + gap] = arr[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			arr[end + gap] = temp;
		}

	}

}
//int Find1(int arr[], int sz)
//{
//	int i = 0;
//	while (i < sz)
//	{
//		if (!(arr[i] - arr[i + 1]))
//		{
//			i += 2;
//		}
//		else
//			return arr[i];
//	}
//	return 0;
//}
//
//int main()
//{
//	int arr[] = { 1,1,4,4,2,2,3,3,8 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	Shell_sort(arr, sz);//这里我们用希尔排序  将数组进行排序
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//	int a=Find1(arr, sz);
//	printf("单身狗是=%d\n", a);
//	return 0;
//}


//那么现在我们就看看用异或是怎么简单解决上面这么多行代码的

//void FindDog1(int arr[], int sz)
//{
//	int dog = 0;
//	for (int i = 0; i < sz; i++)
//	{
//		dog ^= arr[i];
//		//这个是核心 --》 我们首先知道异或是满足结合律和交换律的
//		//dog^=arr[i]  就是将arr数组里的所有元素进行异或   --> 所有成对的元素异或都是0--》那么0与最后的单身狗异或不就是单身狗本身了吗
//	}
//	printf("单身狗的编号是:%d\n", arr[dog]);
//}
//
//int main()
//{
//	int arr[] = { 1,1,4,4,2,2,3,3,8 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	FindDog1(arr, sz);
//	return 0;
//}


//我们现在讲讲2个单身狗的问题
//一样先暴力求解  --》与一个单身狗差不多--》唯一的区别就是函数返回不能在return了  我们需要返回两个单身狗了

//int Find1(int arr1[],int sz,int arr2[])
//{
//	int i = 0;
//	int k = 0;
//	while (i < sz)
//	{
//		if (!(arr1[i] - arr1[i + 1]))
//		{
//			i += 2;
//		}
//		else
//		{
//			arr2[k] = arr1[i];
//			k++;
//			i++;
//			if (k == 2)
//				break;
//		}
//	}
//	return 0;
//}
//
//int main()
//{
//	int arr1[] = { 1,1,4,4,9,2,2,3,3,8 };
//	int arr2[2] = { 0 };
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	Shell_sort(arr1, sz);//这里我们用希尔排序  将数组进行排序
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr1[i]);
//	}
//	printf("\n");
//	Find1(arr1, sz,arr2);
//	printf("单身狗是:");
//	for (int i = 0; i < 2; i++)
//	{
//		printf("%d ", arr2[i]);
//	}
//	return 0;
//}

//拒绝暴力求解
//首先我们得先学会---》位移操作符（  >>右移操作符    <<左移操作符 ）

//左移操作符  : 左边舍弃，右边补0
//int main()
//{
//	int a = 5;
//
//	printf("%d \n", a << 1);
//	//    00000000 00000000 00000000 00000101
//	//  0 00000000 00000000 00000000 00001010
//	//最左边的0抛弃    --》 在最右边补0
//
//	int b = 6;
//	printf("%d \n", b << 1);
//
//	//通过上面我们知道   左移一位就是将数达到*2的效果      2位*4的效果
//
//	return 0;
//}

//   右移操作符  --> 分位逻辑位移    与   算数位移
//逻辑位移  --》 左边补0，右边舍弃
//算数位移  --》左边补原数值符号位，右边舍弃，相比较逻辑位移更加科学，大多数编译器都采用此规则

//int main()
//{
//	int a = -5;
//	printf("%d\n", a >> 1);
//
//	//  原码    10000000  00000000 00000000 00000101
//	//  反码    11111111  11111111 11111111 11111010
//	//  补码    11111111  11111111 11111111 11111011
//
//	//a>>1   :  11111111  11111111 11111111 11111101 1
//	//           最左边补原数值符号位1      最右边1舍弃
//	//   补码       11111111  11111111 11111111 11111101
//	//    反码      11111111  11111111 11111111 11111100
//	//   原码       10000000  00000000 00000000 00000011
//
//	return 0;
//}

//位操作符总结   &    |    ^
//   &   按位与（全1则为1，有0则为0）
//   |   按位或（有1则1，全0则为0）
//   ^   按位异或(相同为0，相异为1)


//那么我们现在再来看两个单身狗问题如何巧妙解决

//void Find_dogs(int arr[], int sz)
//{
//	//先将两个单身狗分成两堆，一堆各一个
//	int ret = 0;
//	int ret1 = 0;
//	int ret2 = 0;
//	for (int i = 0; i < sz; i++)
//	{
//		ret ^= arr[i];
//		//这样子得到的不就是两个单身狗的异或结果了吗
//		//我们在找出异或结果的二进制位上为（1）的位置
//		//这个位置说明这是两个单身狗的不同之处，再利用这个不同之处将两个单身狗分开
//		//最后变成求一个单身狗的问题
//	}
//	for (int i = 1; i <= 32; i++)
//	{
//		if (ret >> 1 & 1)//相同为1  说明找到了1的位置（1也是条件为真）    结束循环
//		{
//			break;
//		}
//	}
//	for (int j = 0; j < sz; j++)
//	{
//		if (arr[j] >> 1 & 1)//将在i位置上是1的数分成一堆
//		{
//			ret1 ^= arr[j];//在同一堆的数进行异或   得到的就是其中的一个单身狗
//		}
//		else//将在i位置上是0的数 分成1一堆
//		{
//			ret2 ^= arr[j];//在同一堆的数全部进行异或   得到的就是另一个单身狗了
//		}
//	}
//	printf("单身狗1:%d , 单身狗2:%d ", ret1, ret2);
//}
//int main()
//{
//	int arr[] = { 3,3,5,5,1,7,2,2 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	Find_dogs(arr, sz);
//	return 0;
//}

































































































