#define _CRT_SECURE_NO_WARNINGS

//电脑中的任何指令都是在cpu上运行的，不过cpu是不存储数据的，只负责运算，数据一般
//都存储在内存和寄存器（存储最常用的数据）

//想要理解函数栈帧的创建和销毁---》必须了解寄存器、常用的汇编指令、内存模型

//寄存器的介绍

// 
// 寄存器的名称                         功能
//-----------------------------------------------------------------
//|          |       累加寄存器，相比较其它寄存器，在运算         |
//|    eax   |               方面比较常用                         |
//|----------------------------------------------------------------
//|          |      基地址寄存器，在内存寻址时，存放基地址        |
//|    ebx   |                                                    |
//|----------------------------------------------------------------
//|          |      计数寄存器，用于循环操作，比如重复的字符存储  |
//|    ecx   |        操作，或者数字统计                          |
//|----------------------------------------------------------------
//|          |      作为EAX的溢出寄存器，总是被用来放整数除法      |
//|    edx   |      产生的余数                                     |
//|-----------------------------------------------------------------
//|          |      源变址寄存器，主要用于存放存储单元的在段内的   |
//|    esi   |偏移量，通常在内存操作指令中作为"源地址指针"使用     |
//|-----------------------------------------------------------------
//|          |     目的变址寄存器，主要用于存放存储单元            |
//|    edi   |    段内偏移量                                       |
//|-----------------------------------------------------------------
//|          |     控制寄存器，存储cpu下次所执行的指令地址         |
//|    eip   |                                                     |
//|------------------------------------------------------------------------------------------
//|          |  栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，esp也就越来越小     |
//|    esp   |  在32为平台上，esp每次减少4字节                                              |
//|          |  栈指针寄存器，其内存放着一个指针，该指针永远指向栈系统最上面一个栈帧的栈顶  |
//|          |   push、pop指令会自动调整esp的值                                             |
//|------------------------------------------------------------------------------------------
//|          |   基址指针，指栈的栈底指针，基址指针寄存器，一般与esp配合使用，可以存取某时刻 |
//|    ebp   |esp，这个时刻就是进入一个函数内后，cpu会将esp的值赋给ebp，此时就可以ebp对栈进行|
//|          |  操作      。 该指针永远指向系统栈最上面一个栈帧的底部                        |
//|-------------------------------------------------------------------------------------------

//什么是栈
//c/c++ 中，每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量

//int Add(int a, int b)
//{
//	int z = 0;
//	z = a + b;
//	return z;
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = 0;
//	c = Add(a, b);
//	return 0;
//}

//main函数是程序的入口，但在底层中main函数又是被其它函数调用(mainCRTStartup（）)其实这个函数
//也是被其它函数调用整个过程是比较复杂的。
//
//---》所以程序在还没有运行之前就已经有栈帧了，这个函数就是   _tmainCRTStartup()函数
//
//
//               |           |
//	             |           |
//    esp  ----> |-----------|      -
//	             |           |      |
//               |           |       _tmainCRTStartup（）函数栈帧
//	             |           |      |
//	  ebp ---->  |-----------|      -
//	             |           |
//	             -------------


//将程序调试     ---》 跳到反汇编

//00DF17C0  push        ebp
//00DF17C1  mov         ebp, esp
//00DF17C3  sub         esp, 0E4h
//00DF17C9  push        ebx
//00DF17CA  push        esi
//00DF17CB  push        edi
//00DF17CC  lea         edi, [ebp - 0E4h]
//00DF17D2  mov         ecx, 39h
//00DF17D7  mov         eax, 0CCCCCCCCh
//00DF17DC  rep stos    dword ptr es : [edi]


//第一条指令   push   --》 将ebp中存放的值（也就是 _tmainCRTStartup函数栈帧的底部的地址）压栈
//这个操作是为了调用完函数后，可以找到原函数的栈帧底部，根据 push 指令  esp+4，指向栈顶
//
// 
//
//               |           |
//     新esp--》 -------------
//	             |     ebp   |       //esp+4指向dbp头顶位置（栈顶）
//     旧esp-》  |-----------|      -
//	             |           |      |
//               |           |       _tmainCRTStartup（）函数栈帧
//	             |           |      |
//	  ebp ---->  |-----------|      -
//	             |           |
//	             -------------


//第二条指令  mov  将esp的值赋给ebp，这个时候esp和ebp同时指向栈顶

//第三条 sub  将esp的值减去了OE4h的大小，进而改变了其指向的位置，这时esp和ebp之间的区域就是为main函数开辟的空间


       //         |           |
       //  esp--》-------------      -
	      //      |           |      |
       //         |           |      main函数栈帧
	      //      |           |
       //         |           |      |
       //esp--》  -------------      -  //esp+4指向dbp头顶位置（栈顶）
	      //      |     ebp   |      
       //         |-----------|      -
	      //      |           |      |
       //         |           |       _tmainCRTStartup（）函数栈帧
	      //      |           |      |
	      //      |-----------|      -
	      //      |           |
	      //      -------------   高地址

//然后有3条push指令  ，将 ebx、esi、edi的值压栈
//接下来的3条指令的目的就是  （ebp-4）指向的位置（main函数栈帧的顶部）到ebp的位置全部赋为OCCCCCCCCh

//函数栈帧结构图


  //           |           |
  //           |           |
  //    esp--》-------------
  //           |    edi    |
  //           -------------
  //           |    esi    |
  //           -------------
	 //        |     ebx   |
	 //        -------------      - 
	 //        |CCCCCCCC   |      |
	 //        |CCCCCCCC   |
	 //        |CCCCCCCC   |
	 //        |CCCCCCCC   |      main函数栈帧
	 //        |CCCCCCCC   |
  //           |CCCCCCCC   |      
	 //        |CCCCCCCC   |      
	 //        |CCCCCCCC   |
	 //        |CCCCCCCC   |      |
	 //esp--》--------------      - //esp+4指向dbp头顶位置（栈顶）
	 //        |  ebp      |
	 //        |-----------|      -
	 //        |           |      |
	 //        |           |       _tmainCRTStartup（）函数栈帧
	 //        |           |      |
	 //        |-----------|      -
	 //        |           |
	 //        -------------  高地址

	//到这里main函数的栈帧就创建完毕，并进行了初始化，也就是说可以再


//int a = 10;
//00B84438  mov         dword ptr[ebp - 8], 0Ah
//int b = 20;
//00B8443F  mov         dword ptr[ebp - 14h], 14h
//int c = 0;
//00B84446  mov         dword ptr[ebp - 20h], 0

//在汇编语言中,word表示两个字节，dword表示4个字节  

//所以下面这句意思就是将[ebp-8]指向的四个字节的内容赋值为OAh,也就是赋值为10，main函数的局部整形变量a就创建完成了
//b、c同理
//int a = 10;
//00B84438  mov         dword ptr[ebp - 8], 0Ah

//栈帧结构图

//	          |           |
//	          |           |
//     esp--》-------------
//	          | edi       |
//	          -------------
//	          |   esi     |
//	          -------------
//	          | ebx       |
//	          -------------      -
//	          |CCCCCCCC   |
//	          |CCCCCCCC   |
//c ebp-20h-->|00000000   |      |
//	          |CCCCCCCC   |
//	          |CCCCCCCC   |
//b ebp-14h-->|14000000   | main函数栈帧
//	          |CCCCCCCC   |
//	          |CCCCCCCC   |
//a	ebp-8-->  |Oa000000   |
//	          |CCCCCCCC   |      |
//  ebp-->    |------------      - //esp+4指向dbp头顶位置（栈顶）
//	          | ebp       |
//	          |-----------|      -
//	          |           |      |
//            |           |       _tmainCRTStartup（）函数栈帧
//	          |           |      |
//	          |-----------|      -
//	          |           |
//	          ------------- 高地址


//所以如果创建一个变量没有并没有对其进行初始化，变量会随机存储一个随机值，这个随机值就是编译器初始化栈时的值
//到这里定义3个变量的语句结束，程序开始调用我们一开始创建的Add函数，第一步传参的操作

//0043444D  mov         eax, dword ptr[ebp - 14h]
//00434450  push        eax
//00434451  mov         ecx, dword ptr[ebp - 8]
//00434454  push        ecx
//
//首先通过mov指令    将[ebp-14h]指向的四个字节的内容赋给寄存器eax
//然后将eax的值压栈   ，后面的两个操作与上面的一致
//
//其中先压栈eax，eax指向的的变量b，后压栈ecx，ecx指向的变量a
//
//可知函数传参的顺序是按照参数列表从左往右传值的，并且函数传参就是一个简单值的拷贝
//
//               |           |
//       esp-->  -------------
//	             |   ecx  a  |
//               -------------
//	             |   eax  b  |
//	             -------------
//	             |  edi      |
//	             -------------
//	             |  esi      |
//	             -------------
//	             |   ebx     |
//	             -------------
//	             |CCCCCCCC   |
//	             |CCCCCCCC   |
//	             |           |


//紧接着执行call指令 ，call指令就是将下一个语句的地址压栈，在后续的ret指令会根据这个指令回到原函数
//，回到原函数之后会将这个地址出栈，   --》这个指令的目的是为了后调用函数之后，能够回到原函数



//      esp--》  --------------------
//               |call-指令的压栈操作|
//               -------------
//	             |   ecx  a  |
//               -------------
//	             |   eax  b  |
//	             -------------
//	             |  edi      |
//	             -------------
//	             |  esi      |
//	             -------------
//	             |   ebx     |
//	             -------------


//调用Add函数   ---》首先为Add 函数开辟栈帧

//与之前调用main函数时的所进行的操作一致-->先是将ebp的值压栈，以便调用完Add函数之后找到main函数
//的栈帧底部，随后也是为Add函数开辟栈帧，并将栈帧中空间的值全部初始化为OCCCCCCCCh


//       |          |
//esp--》------------
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//	     |CCCCCCCC  |
//		 |CCCCCCCC  |
//		 |CCCCCCCC  |
//		 |CCCCCCCC  |
//ebp--> ------------
//		 |  ebp     |
//		 ------------
//		 |call-指令的压栈操作
//		 -------------


//int z = 0;
//004325C8  mov         dword ptr[ebp - 8], 0


//创建一个整形变量  ， 并对其进行赋值

         
//             |CCCCCCCC  |
//z   ebp-8--> |00000000  |
//	           |CCCCCCCC  |
//	           ------------
//             |  ebp     |


//	z = a + b;
//004325CF  mov         eax, dword ptr[ebp + 8]
//004325D2  add         eax, dword ptr[ebp + 0Ch]
//004325D5  mov         dword ptr[ebp - 8], eax
//return z;
//004325D8  mov         eax, dword ptr[ebp - 8]

//然后进行相加操作，分别取到之前传参的值  ebp+8取到的就是a的值
//ebp+OCh取到的就是b的值，然后通过Add指令求和并将和放入eax中，最后将eax的值赋给之前创建的变量z
//最后将z的值进行返回操作，将z的值赋值给eax，完成函数返回值的返回操作

//到这里我们更加清晰的认识到了函数返回值的返回与参数传递一样，都是值的拷贝



//接下来就是Add函数的销毁

//004325DB  pop         edi
//004325DC  pop         esi
//004325DD  pop         ebx
//004325DE  add         esp, 0CCh
//004325EB  mov         esp, ebp
//004325ED  pop         ebp
//004325EE  ret


//首先进行3次pop指令，pop指令就是出栈，将位于栈顶的值消除，并将这个值放入edi寄存器中  --》 esp+12


    //  esp---》  -----------
	   //         |CCCCCCCC |
	   //         |……     |
	   //ebp+8--> |00000000 |
	   //         |CCCCCCCC |
	   //  ebp--> -----------
	   //         |ebp      |
	   //         -----------

//esp的值再加上OCCh，并将ebp的值赋值给esp，使得esp和ebp指向同一个位置

//           -------------
//           |CCCCCCCC   | 
//	       |CCCCCCCC   |
//ebp+8-》   |00000000   |
//           |CCCCCCCC   |
//esp、ebp-》-------------
//           |   ebp     |
//	       -------------

	//进行pop操作，这时位于栈顶的值也就是之前main函数的栈帧底部的地址 ，将其出栈，并将这个值赋给ebp，此时ebp指向的是main函数的栈帧底部

//esp->    	------------------
//        	|call-指令的压栈操作
//        	---------------
//        	|eax   a      |
//	        ---------------
//	        |ecx   b      |
//	        ---------------
//	        |edi          |
//	        ---------------
//	        |esi          |
//	        ---------------
//	        |ebx          |           main函数栈帧
//	        ---------------
//	        |CCCCCCCC     |
//c ebp-20h-> ---------------
//	        |00000000     |
//	        --------------
//	         ……
//  ebp-》    --------------
//	        |      ebp    |
//	        --------------

	//到这里就完成了Add函数栈帧的销毁
	//接下来调用ret指令，返回到之前main函数的下一步操作，然后将call指令存储的地址出栈
//
//	0043445A  add         esp, 8
//	0043445D  mov         dword ptr[ebp - 20h], eax
//	return 0;
//00434460 xor eax, eax
//}
//00434462  pop         edi
//00434463  pop         esi
//00434464  pop         ebx
//00434465  add         esp, 0E4h
//0043446B  cmp         ebp, esp
//0043446D  call        00431235
//00434472  mov         esp, ebp
//00434474  pop         ebp
//00434475  ret

//首先将esp地址+8   这里是将形参a，b返还给操作系统

    //   esp--》 ------------
	   //        | edi       |
    //          --------------
	   //          ……
	   //edp--》 --------------
	   //        |edp        |
	   //        ------------

	//然后将之前存放的Add函数返回的eax寄存器赋值给之前在main函数中创建变量的c，到这里Add函数的返回值成功被main函数的变量接收

	//最后再进行main函数栈帧的销毁













